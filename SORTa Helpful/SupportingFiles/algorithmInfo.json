{
    "Bubble Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n²)", 10],
        "worstCase": ["O(n²)", 10],
        "memory": "O(1)",
        "info": "Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements bubble to the top of the list."
        
    },
    "Selection Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(n²)", 10],
        "averageCase": ["O(n²)", 10],
        "worstCase": ["O(n²)", 10],
        "memory": "O(1)",
        "info": "The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array. 1) The subarray which is already sorted. 2) Remaining subarray which is unsorted. In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray."
    },
    "Insertion Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n²)", 10],
        "worstCase": ["O(n²)", 10],
        "memory": "O(n²)",
        "info": "Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time."
    },
    "Heap Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(nlogn)", 6],
        "worstCase": ["O(nlogn)", 6],
        "memory": "O(1)",
        "info": "The heapsort algorithm involves preparing the list by first turning it into a max heap. The algorithm then repeatedly swaps the first value of the list with the last value, decreasing the range of values considered in the heap operation by one, and sifting the new first value into its position in the heap. This repeats until the range of considered values is one value in length."
    },
    "Cocktail Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n²)", 10],
        "worstCase": ["O(n²)", 10],
        "memory": "O(1)",
        "info": "Cocktail shaker sort, also known as bidirectional bubble sort, cocktail sort, shaker sort (which can also refer to a variant of selection sort), ripple sort, shuffle sort, or shuttle sort, is a variation of bubble sort that is both a stable sorting algorithm and a comparison sort. The algorithm differs from a bubble sort in that it sorts in both directions on each pass through the list. This sorting algorithm is only marginally more difficult to implement than a bubble sort, and solves the problem of turtles in bubble sorts."
    },
    "Merge Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(nlogn)", 6],
        "averageCase": ["O(nlogn)", 6],
        "worstCase": ["O(nlogn)", 6],
        "memory": "O(n)",
        "info": "Merge sort (also commonly spelled mergesort) is an efficient, general-purpose, comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output. Merge sort is a divide and conquer algorithm that was invented by John von Neumann in 1945."
    },
    "Quick Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(nlogn)", 6],
        "averageCase": ["O(nlogn)", 6],
        "worstCase": ["O(n²)", 10],
        "memory": "O(log(n))",
        "info": "Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order."
    },
    "Shell Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(nlogn)", 6],
        "averageCase": ["O(nlogn)", 6],
        "worstCase": ["O(n²)", 10],
        "memory": "O(1)",
        "info": "Shell sort is a generalization of insertion sort that allows the exchange of items that are far apart. The idea is to arrange the list of elements so that, starting anywhere, considering every hth element gives a sorted list. Such a list is said to be h-sorted. Equivalently, it can be thought of as h interleaved lists, each individually sorted."
    },
    "Counting Sort": {
        "algoClass": "Non-comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n+r) ≈ O(n)", 2],
        "worstCase": ["O(n+r) ≈ O(n)", 2],
        "memory": "O(n+r)",
        "info": "Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum and minimum key values, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently."
    },
    "Radix Sort": {
        "algoClass": "Non-comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n(k/d)) ≈ O(n)", 3],
        "worstCase": ["O(n(k/d)) ≈ O(n)", 3],
        "memory": "O(n+2ᵈ)",
        "info": "A Least significant digit (LSD) Radix sort is a fast stable sorting algorithm which can be used to sort keys in integer representation order. Keys may be a string of characters, or numerical digits in a given 'radix'. The processing of the keys begins at the least significant digit (i.e., the rightmost digit), and proceeds to the most significant digit (i.e., the leftmost digit). The sequence in which digits are processed by an LSD radix sort is the opposite of the sequence in which digits are processed by a most significant digit (MSD) radix sort."
    },
    "Binary Insertion Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(nlogn)", 6],
        "averageCase": ["O(n²)", 10],
        "worstCase": ["O(n²)", 10],
        "memory": "O(1)",
        "info": "Compared to normal Insertion Sort, if the cost of comparisons exceeds the cost of swaps, as is the case for example with string keys stored by reference or with human interaction (such as choosing one of a pair displayed side-by-side), then using binary insertion sort may yield better performance. Binary insertion sort employs a binary search to determine the correct location to insert new elements, and therefore performs logn comparisons in the worst case, which is O(nlogn). The algorithm as a whole still has a running time of O(n²) on average because of the series of swaps required for each insertion."
    },
    "Comb Sort": {
        "algoClass": "Comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n²)", 10],
        "worstCase": ["O(n²)", 10],
        "memory": "O(1)",
        "info": "In bubble sort, when any two elements are compared, they always have a gap (distance from each other) of 1. The basic idea of comb sort is that the gap can be much more than 1. The inner loop of bubble sort, which does the actual swap, is modified such that gap between swapped elements goes down."
    },
    "Pigeonhole Sort": {
        "algoClass": "Non-comparison",
        "algoType": "In-place",
        "bestCase": ["O(n)", 1],
        "averageCase": ["O(n+2ᵏ) ≈ O(n)", 5],
        "worstCase": ["O(n+2ᵏ) ≈ O(n)", 5],
        "memory": "O(2ᵏ)",
        "info": "Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements (n) and the length of the range of possible key values (N) are approximately the same. It requires O(n + N) time. It is similar to counting sort, but differs in that it moves items twice: once to the bucket array and again to the final destination [whereas] counting sort builds an auxiliary array then uses the array to compute each item's final destination and move the item there."
    }
}
